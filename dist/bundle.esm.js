function t (t, n) { let r = typeof Symbol !== 'undefined' && t[Symbol.iterator] || t['@@iterator']; if (!r) { if (Array.isArray(t) || (r = (function (t, n) { if (!t) return; if (typeof t === 'string') return e(t, n); let r = Object.prototype.toString.call(t).slice(8, -1); r === 'Object' && t.constructor && (r = t.constructor.name); if (r === 'Map' || r === 'Set') return Array.from(t); if (r === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return e(t, n) }(t))) || n && t && typeof t.length === 'number') { r && (t = r); let a = 0; const o = function () {}; return { s: o, n: function () { return a >= t.length ? { done: !0 } : { done: !1, value: t[a++] } }, e: function (t) { throw t }, f: o } } throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') } let i; let f = !0; let c = !1; return { s: function () { r = r.call(t) }, n: function () { const t = r.next(); return f = t.done, t }, e: function (t) { c = !0, i = t }, f: function () { try { f || r.return == null || r.return() } finally { if (c) throw i } } } } function e (t, e) { (e == null || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function n (t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function r (t) { return r = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t }, r(t) } let a; const o = new WeakMap(); let i = !0; function f () { i = !1 } function c () { i = !0 } function u (t) { a = t } function s (t, e, n) { const r = o.get(t); if (r) { const a = r.get(e); a && a.forEach(function (r) { if (r.__cb__Map) { const a = r.__cb__Map.get(t); a && a(e, n) } else r.setData(function (t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t }({}, e, n)) }) } } function l (t) { if (!(function (t) { return r(t) === 'object' && t !== null }(t))) throw new Error('state must be a Object!!!'); return new Proxy(t, { get: function (t, e, n) { return (function (t, e) { if (a && i) { let n = o.get(t); n || (n = new Map(), o.set(t, n)); let r = n.get(e); r || (r = new Set(), n.set(e, r)), r.add(a) } }(t, e)), Reflect.get(t, e, n) }, set: function (t, e, n, r) { const a = Reflect.set(t, e, n, r); return s(t, e, n), a } }) } const y = (function () { function e (t) { !(function (t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') }(this, e)), this.rawState = t.state, this.actions = t.actions, this.state = l(t.state) } let r, a, i; return r = e, a = [{ key: 'saveEffectKeys', value: function (t) { const e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []; const n = t.__effectKeysMap__ || new Map(); n.set(this.rawState, e), t.__effectKeysMap__ = n } }, { key: 'saveCb', value: function (t, e) { const n = t.__cb__Map || new Map(); n.set(this.rawState, e), t.__cb__Map = n } }, { key: 'useData', value: function (e) { const n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = n.useKeys; const a = void 0 === r ? [] : r; const o = n.total; const i = void 0 !== o && o; const f = n.immediate; const c = void 0 === f || f; const s = n.cb; const l = (a == null ? void 0 : a.length) || 0; if (i || l !== 0) { const y = i ? Object.keys(this.state) : a; u(e), s && this.saveCb(e, s), this.saveEffectKeys(e, y); let v; const b = {}; const h = t(y); try { for (h.s(); !(v = h.n()).done;) { const p = v.value; const d = this.state[p]; !s && c && (b[p] = d), s && c && s(p, d) } } catch (t) { h.e(t) } finally { h.f() }!s && c && e.setData(b) } } }, { key: 'unUseData', value: function (e) { let n; const r = o.get(this.rawState); if (r) { let a; const i = t(((n = e.__effectKeysMap__) === null || void 0 === n ? void 0 : n.get(this.rawState)) || []); try { for (i.s(); !(a = i.n()).done;) { const f = a.value; const c = r.get(f); if (!c) break; c.delete(e), c.size === 0 && r.delete(f) } } catch (t) { i.e(t) } finally { i.f() }r.size === 0 && o.delete(this.rawState) } } }, { key: 'dispatch', value: function (t) { if (this.actions) { if (f(), !this.actions[t]) throw new Error('找不到'.concat(String(t), '对应的action')); if (typeof this.actions[t] !== 'function') throw new Error(''.concat(String(t), '对应的value不是一个函数')); for (var e, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)r[a - 1] = arguments[a]; (e = this.actions[t]).call.apply(e, [null, this.state].concat(r)), c() } } }], a && n(r.prototype, a), i && n(r, i), Object.defineProperty(r, 'prototype', { writable: !1 }), e }()); export { y as default }
